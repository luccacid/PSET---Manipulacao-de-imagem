	Inicialmente as funções get e set_pixel() precisaram ser corrigidas. Por self.pixels ser um array unidimensional, o índice é um único inteiro, e o código, originalmente, tratava como uma matriz bidimensional e utilizava uma tupla para representar a posição do pixel. Alem disso, foi implementado um tratamento para pixels "além da borda", que auxiliara quando o kernel for aplicado sob a imagem.
	Em seguida a função aplicar_por_pixel() precisou ser corrigida pois invertia a altura(y) e a largura(x), tanto nos loops, quanto nas funções chamadas. Também foi alterada a função invertida(), o valor 256 foi alterado para 255, o valor máximo para um pixel.
	Implementação do método teste_invertida2(), para uma imagem (4,1, [29, 89, 136, 200]).
	Em seguida, a função borrada() foi implementada para aplicar um filtro de desfoque à imagem. Nessa função, eu utilizei o método kernel_borrado() para gerar um kernel de desfoque, que é uma matriz que vai ser usada para calcular a média dos pixels vizinhos. O método percorre cada pixel da imagem, calcula a média ponderada dos valores dos pixels em torno dele com base no kernel, e armazena o resultado em uma nova imagem. Para garantir que os valores resultantes estejam dentro do intervalo válido de 0 a 255, eu utilizei a função max() e min().
	Depois disso, implementei o método focada(), que aplica uma máscara de nitidez à imagem. Esse método funciona gerando uma versão borrada da imagem, e em seguida, calcula um novo valor para cada pixel baseado na diferença entre o pixel original e o correspondente na imagem borrada. O novo valor é calculado utilizando a fórmula 2 * original - borrado. Novamente, garanti que os valores permanecessem dentro do intervalo de 0 a 255.
	A seguir, desenvolvi o método bordas(), que utiliza o operador Sobel para detectar bordas na imagem. Eu defini dois kernels, Kx e Ky, que são utilizados para calcular as derivadas da imagem em direções horizontal e vertical, respectivamente. Para cada pixel, apliquei esses kernels e calculei a magnitude do vetor gradiente. Os valores resultantes foram arredondados e limitados entre 0 e 255 antes de serem armazenados na nova imagem.